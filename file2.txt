int f_write(void* buffer, int size, int ntimes, int fd ) {
    //check if the file accociated with this fd has been open
    // superblock* sp = current_mounted_disk->superblock1;
    if (file_table[fd]->free_file == TRUE) {
        printf("%s\n", "The file must be open before write");
        return (EXITFAILURE);
    }
    if (file_table[fd]->access == READ) {
        printf("%s\n", "File is not readable.");
        return EXITFAILURE;
    }
    if (file_table[fd]->file_inode->type == REG) {
        printf("%s\n", "writing to a regular file");
        superblock *sp = current_mounted_disk->superblock1;
        //need to double check this
        void *datatowrite = malloc(size * ntimes);
        for (int j = 0; j < ntimes; j++) {
            memcpy(datatowrite + j * size, buffer, size);
        }
        int lefttowrite = size * ntimes;
        if (file_table[fd]->access == APPEND || file_table[fd]->access == READ ||
            file_table[fd]->access == READANDWRITE) {
            //get the last data block of the file.
            void *last_data_block = malloc(BLOCKSIZE);
            // void *copy = get_data_block(file_table[fd]->file_inode->last_block_index); //TODO: ask rose about this line!
            int index = -1;
            void *copy = get_block_from_index(file_table[fd]->file_inode->size/BLOCKSIZE, file_table[fd]->file_inode, &index);
            memcpy(last_data_block, copy, BLOCKSIZE);
            free(copy);
            // file_table[fd]->byte_offset = file_table[fd]->file_inode->size;
            int offset_into_last_block = 0;
            int old_offset = 0;
            int old_filesize = 0;
            if (file_table[fd]->access == APPEND) {
                offset_into_last_block = file_table[fd]->file_inode->size % BLOCKSIZE;
                old_offset = file_table[fd]->file_inode->size;
                printf("old file_size: %d\n", old_offset);
                old_filesize = old_offset;
            } else {
                offset_into_last_block = file_table[fd]->byte_offset % BLOCKSIZE;
                old_offset = file_table[fd]->byte_offset;
                old_filesize = file_table[fd]->file_inode->size;
            }
            int free_space = BLOCKSIZE - offset_into_last_block;
            if (free_space < size * ntimes && sp->free_block == -1) {
                printf("%s\n", "Not having enough space on the disk");
                free(datatowrite);
                free(last_data_block);
                return EXITFAILURE;
            }
            //TODO. complete the check of enough free space on disk
            int start_of_block_to_write = -1;
            int new_offset = old_offset + size * ntimes;
            // int file_offset = old_offset;
            int datatowrite_offset = 0;
            int total_block = 0;
            if (free_space == 0) {
                printf("%s\n", "dont need to fill the the last block");
                if (file_table[fd]->access != APPEND) {
                    int block_written = file_table[fd]->byte_offset / BLOCKSIZE;
                    total_block = block_written + 1; // the block we are writing to in the future
                }
            } else {
                printf("%s\n", "do need to fill in the last block");
                void *data = malloc(BLOCKSIZE);
                //copy the data from the last block to data
                memcpy(data, last_data_block, offset_into_last_block);
                if (sizeof(datatowrite) < free_space) {
                    memcpy(data + offset_into_last_block, datatowrite, sizeof(datatowrite));
                } else {
                    memcpy(data + offset_into_last_block, datatowrite, free_space);
                }
                if (file_table[fd]->access == APPEND) {
                    // printf("%s\n", "appending to file");
                    // write_data_to_block(file_table[fd]->file_inode->last_block_index, data, sp->size);
                    write_data_to_block(index, data, sp->size);
                } else {
                    // printf("%s\n", "writing to file");
                    total_block = file_table[fd]->byte_offset / BLOCKSIZE + 1;
                    start_of_block_to_write = find_next_datablock(file_table[fd]->file_inode, total_block, old_filesize,
                                                                  file_table[fd]->byte_offset);
                    write_data_to_block(start_of_block_to_write, data, sp->size);
                }
                if (free_space < ntimes * size) {
                    file_table[fd]->byte_offset += free_space;
                    file_table[fd]->file_inode->size += free_space;
                    datatowrite_offset += free_space;
                } else {
                    file_table[fd]->byte_offset += ntimes * size;
                    file_table[fd]->file_inode->size += ntimes * size;
                    datatowrite_offset += ntimes * size;
                }
                update_single_inode_ondisk(file_table[fd]->file_inode, file_table[fd]->file_inode->inode_index);
                lefttowrite -= free_space;
                // printf("lefttowrite: %d\n", lefttowrite);
                free(data);
                free(last_data_block);
                // file_offset += free_space;
                total_block += 1;
            }
            while (lefttowrite > 0) {
                start_of_block_to_write = find_next_datablock(file_table[fd]->file_inode, total_block, old_filesize,
                                                              file_table[fd]->byte_offset);
                // printf("lefttowrite: %d\n", lefttowrite);
                int size_to_write = BLOCKSIZE;
                void *data = malloc(BLOCKSIZE);
                if (lefttowrite < BLOCKSIZE) {
                    size_to_write = lefttowrite;
                }
                memcpy(data, datatowrite + datatowrite_offset, size_to_write);
                write_data_to_block(start_of_block_to_write, data, size_to_write);
                lefttowrite -= size_to_write;
                // file_offset += size_to_write;
                free(data);
                file_table[fd]->byte_offset += size_to_write;
                if (file_table[fd]->access == APPEND) {
                    file_table[fd]->file_inode->size += size_to_write;
                } else {
                    if (file_table[fd]->file_inode->size < file_table[fd]->byte_offset) {
                        file_table[fd]->file_inode->size = file_table[fd]->byte_offset;
                    }
                }
                total_block += 1;
                file_table[fd]->file_inode->last_block_index = start_of_block_to_write;
                update_single_inode_ondisk(file_table[fd]->file_inode, file_table[fd]->file_inode->inode_index);
            }
            file_table[fd]->byte_offset = new_offset;
            // printf("new_offset: %d\n", new_offset);
            free(datatowrite);
            // printf("total_blocks: %d\n", total_block);
            return size * ntimes;
        }
        //else if(file_table[fd]->access == WRITE || file_table[fd]->access == READANDWRITE){
        //     //need to overwite the file
        //     int start_block_index;
        //     int inode_num = file_table[fd]->byte_offset / BLOCKSIZE;
        //     int idtotal = N_IBLOCKS * BLOCKSIZE;
        //     int i2total = BLOCKSIZE * BLOCKSIZE;
        //     int i3total = i2total * BLOCKSIZE;
        //     if (inode_num < N_DBLOCKS){
        //       //update the dblocks
        //       start_block_index = file_table[fd]->file_inode->dblocks[inode_num];
        //     }else if(inode_num - N_DBLOCKS < idtotal){
        //       //update the idblocks.TODO
        //       int id_index = (inode_num - N_DBLOCKS)/BLOCKSIZE;//id_index <=4
        //
        //     }else if(inode_num - N_DBLOCKS - idtotal < i2total){
        //       //update the i2blocks.TODO
        //     }else if(inode_num - N_DBLOCKS- idtotal - i2total < i3total){
        //       //
        //     void* startplace_disk = get_data_block(start_block_index);
        //     int new_offset = ntimes*size;
        //     int old_file = file_table[td]->byte_offset;
        //     int offset = 0;   //offset in datatowrite
        //     //write to dblocks
        //     for(int i=0; i<N_DBLOCKS; i++){
        //       if (lefttowrite <= 0){
        //         return size*ntimes;
        //       }
        //       write_data_to_block(start_block_index, datatowrite, BLOCKSIZE);
        //       start_block_index = file_table[fd]->file_inode->dblocks[1];
        //       startplace_disk = get_data_block(start_block_index);
        //       lefttowrite -= sp->size;
        //       offset += sp->size;
        //       old_file -= BLOCKSIZE;
        //       if(old_file <= 0){
        //         //need to rewrite dblocks
        //       }
        //     }
        //     for(int i = 0; i <N_IBLOCKS; i++){
        //       if (lefttowrite <=0){
        //         return sizeof(buffer);
        //       }
        //     }
        //   }
    } else if (file_table[fd]->file_inode->type == DIR) {
        printf("%s\n", "writing to a dir file");
        //make_dir should do the same thing
    }
    return EXITSUCCESS;
}
